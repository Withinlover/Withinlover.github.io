<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用GF(2^8)生成Sbox</title>
      <link href="/2022/12/14/%E5%88%A9%E7%94%A8GF-2-8-%E7%94%9F%E6%88%90Sbox/"/>
      <url>/2022/12/14/%E5%88%A9%E7%94%A8GF-2-8-%E7%94%9F%E6%88%90Sbox/</url>
      
        <content type="html"><![CDATA[<h1 id="Sbox-生成原理"><a href="#Sbox-生成原理" class="headerlink" title="Sbox 生成原理"></a>Sbox 生成原理</h1><p>Aes 算法的 S 盒是定义在 $GF(2^8)$ 中，使用的不可约多项式为 $x^8+x^4+x^3+x+1$，生成方式为 $S(x)=Ax^{-1}+c$</p><script type="math/tex; mode=display">A=\left(\begin{array}{l}1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\\end{array}\right)c=\left(\begin{array}{l}0 \\1 \\1 \\0 \\0 \\0 \\1 \\1 \\\end{array}\right)</script><p>在 SM4 的官方文档中，仅给出了 Sbox 盒的定义， 并未给出生成方法。进行学术搜索后，在论文 <a href="https://www.researchgate.net/profile/Jintai-Ding/publication/220798661_Analysis_of_the_SMS4_block_cipher/links/5ce4735a92851c4eabb4e554/Analysis-of-the-SMS4-block-cipher.pdf" target="_blank" rel="noopener">Analysis of the SMS4 Block Cipher</a> 中提到，SM4 算法的 S 盒同样定义在 $GF(2^8)$ 中。使用的不可约多项式为 $x^8+x^7+x^6+x^5+x^4+x^2+1$，生成方式为 $S(x)=A(Ax+c)^{-1}+c$</p><script type="math/tex; mode=display">A=\left(\begin{array}{l}1 & 1 & 0 & 1 & 0 & 0 & 1 & 1 \\1 & 1 & 1 & 0 & 1 & 0 & 0 & 1 \\1 & 1 & 1 & 1 & 0 & 1 & 0 & 0 \\0 & 1 & 1 & 1 & 1 & 0 & 1 & 0 \\0 & 0 & 1 & 1 & 1 & 1 & 0 & 1 \\1 & 0 & 0 & 1 & 1 & 1 & 1 & 0 \\0 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\\end{array}\right)c=\left(\begin{array}{l}1 \\1 \\0 \\1 \\0 \\0 \\1 \\1 \\\end{array}\right)</script><h1 id="SM4-SBox-生成方法"><a href="#SM4-SBox-生成方法" class="headerlink" title="SM4-SBox 生成方法"></a>SM4-SBox 生成方法</h1><p>伽罗瓦域 $GF(2^8)$ 上的四则运算是基于多项式进行计算的。</p><ul><li>加法：多项式对应项系数相加，由于每一项的系数都是在 $GF(2)$ 上进行运算，结果要对 2 取模。表现出来就是异或运算。</li><li>减法：在 $GF(2^8)$ 中，加减法最终都是异或运算。</li><li>乘法：选取不可约多项式 $x^8+x^7+x^6+x^5+x^4+x^2+1$，当出现大于 $x^8$ 的项时，将 $x^8$ 替换为 $x^7+x^6+x^5+x^4+x^2+1$ </li><li>除法：除以一个多项式等价于乘它的逆元。</li></ul><p>在将上述 Sbox 的计算公式翻译为代码时，加减法可以直接使用异或运算完成，乘除法的计算过程相对麻烦，但由于 $GF(2^8)$ 中除去 0 仅有 255 个多项式，可以打表实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BIT gen = <span class="number">0b11110101</span>;</span><br><span class="line">BIT table[<span class="number">256</span>], arc_table[<span class="number">256</span>], inv_table[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用生成元 g = x 遍历所有元素</span></span><br><span class="line">    <span class="comment">// 任意多项式 A, B 都可以写为 g^a, g^b 的形式</span></span><br><span class="line">    table[<span class="number">0</span>] = <span class="number">1</span>; arc_table[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">255</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i - <span class="number">1</span>] &amp; <span class="number">0x80</span>) </span><br><span class="line">            table[i] = (table[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) ^ gen;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            table[i] = table[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        arc_table[table[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 首先从 g^a -&gt; a</span></span><br><span class="line">        <span class="comment">// 利用 A*B = g^a * g^b = g^(a + b) = 1，定位 B</span></span><br><span class="line">        BIT k = arc_table[i]; </span><br><span class="line">        inv_table[i] = table[(<span class="number">255</span> - k) % <span class="number">255</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述 3 个表，我们可以快速实现 $GF(2^8)$ 上的乘除法运算。</p><p>之后按照定义将 Sbox 的生成函数写出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BIT A[] = &#123;<span class="number">0b11100101</span>, <span class="number">0b11110010</span>, <span class="number">0b01111001</span>, <span class="number">0b10111100</span>, <span class="number">0b01011110</span>, <span class="number">0b00101111</span>, <span class="number">0b10010111</span>, <span class="number">0b11001011</span>&#125;;</span><br><span class="line"><span class="function">BIT <span class="title">Ax</span><span class="params">(BIT x)</span> </span>&#123;</span><br><span class="line">    BIT y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; ++i) </span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">7</span> - i)))</span><br><span class="line">            y ^= A[i]; <span class="comment">// y = Ax</span></span><br><span class="line">    <span class="keyword">return</span> y ^ <span class="number">0xd3</span>; <span class="comment">// return Ax + c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BIT <span class="title">sbox_gen</span><span class="params">(BIT x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// res = A(Ax + c)^-1 + c </span></span><br><span class="line">    <span class="keyword">return</span> Ax(inv_table[Ax(x)]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">256</span>; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%02x%c"</span>, sbox_gen(i - <span class="number">1</span>), <span class="string">",\n"</span>[i % <span class="number">16</span> == <span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05</span><br><span class="line">0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99</span><br><span class="line">0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62</span><br><span class="line">0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6</span><br><span class="line">0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8</span><br><span class="line">0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35</span><br><span class="line">0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87</span><br><span class="line">0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e</span><br><span class="line">0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1</span><br><span class="line">0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3</span><br><span class="line">0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f</span><br><span class="line">0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51</span><br><span class="line">0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8</span><br><span class="line">0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0</span><br><span class="line">0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84</span><br><span class="line">0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48</span><br></pre></td></tr></table></figure><p>其实这样的方案在硬件实现上并无优势，朴素的实现需要将 Sbox 全部存储下来（利用 ROM），需要存储 256 份的信息。利用 $GF(2^8)$ 进行计算时，也同样需要预先打出逆元的表。</p><p>当然，这个方法也不是一无是处，如果能找到 $GF(2^8)\to GF((2^4)^2)$ 的对应方案，便可以不利用 ROM 使用纯粹的组合逻辑实现 SM4-Sbox。</p><p>这是作者第一次接触到这部分知识点，难免有疏漏或错误的地方，如果有发现还请指出。</p>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SM4 </tag>
            
            <tag> Sbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SM4 密码算法学习</title>
      <link href="/2022/12/04/SM4-CPP/"/>
      <url>/2022/12/04/SM4-CPP/</url>
      
        <content type="html"><![CDATA[<h1 id="SM4-算法概述"><a href="#SM4-算法概述" class="headerlink" title="SM4 算法概述"></a>SM4 算法概述</h1><p>SM4是一种分组密码算法，由我国国家密码管理局在2012年发布，常用于无线互联网加密等领域。</p><h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码是将一个明文作为整体加密并且通常得到的是与明文等长的密文分组。典型的分组大小是64位或者128位。同流密码一样，两个用户要共享一个对称加密密钥。</p><p>分组密码的输入为具有 $b$ 位长度固定的明文分组和密钥，输出为 $b$ 位的密文。明文长度若大于 $b$ 位，则可简单将其分为 $b$ 位一组的块。</p><h2 id="工作模式概述"><a href="#工作模式概述" class="headerlink" title="工作模式概述"></a>工作模式概述</h2><p>但是，每次使用相同的密钥队多个分组加密，则会引发许多安全问题（如对于相同的明文永远生成唯一的密文）。为了将分组密码应用于各种各样的实际应用，NIST 定义了五种“工作模式”。</p><ul><li>ECB：用相同的密钥队明文分组分别加密。</li><li>CBC：明文输入时上一个密文组和下一个明文组的异或。</li><li>CFB：一次处理 $s$ 位，上一次的密文作为输入，输出与明文异或。</li><li>OFB：与 CFB 类似，用加密函数的输出填充移位寄存器。</li><li>CTR：加密一个计数器，输出与明文异或。</li></ul><h1 id="SM4-算法流程"><a href="#SM4-算法流程" class="headerlink" title="SM4 算法流程"></a>SM4 算法流程</h1><p>SM4 算法采用 32 轮非对称 Feistel 结构，其明文和密文长度都是 128 位，加密过程和解密过程处了轮密钥的使用顺序相反外，其他都是一致的。 SM4 算法的整体结构如下图所示：</p><p><img src="SM4.png" alt="SM4算法流程"></p><p>SM4 主要涉及 3 种操作：轮密钥异或，非线性变换和线性变换。</p><ul><li>轮密钥异或指当前分组和当前轮密钥进行按位异或运算。</li><li>非线性变换通过 S 盒完成，实现密码算法的混淆。</li><li>线性变换指的是对非线性变换的输出进行拓展操作。</li></ul><h2 id="非线性变换"><a href="#非线性变换" class="headerlink" title="非线性变换"></a>非线性变换</h2><p>由 4 个并行的 S 盒完成，每个 S 盒映射 8 位，整体上实现对 32 位输入的映射，记为 $\tau(\cdot)$：</p><p><img src="SBOX.jpg" alt="SBOX"></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>输入是非线性变换的输出，完成的是对 32 位输入的线性变换，记为 $L(\cdot)$：</p><script type="math/tex; mode=display">L(B)=B\oplus (B<<<2)\oplus (B<<<10)\oplus (B<<<18)\oplus (B<<<24)</script><p>其中用到的移位运算是 <strong>循环右移</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BYTE <span class="title">roll</span><span class="params">(BYTE x, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n));&#125; <span class="comment">// 循环右移</span></span><br><span class="line"><span class="function">BYTE <span class="title">L1</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> x ^ roll(x, <span class="number">2</span>) ^ roll(x, <span class="number">10</span>) ^ roll(x, <span class="number">18</span>) ^ roll(x, <span class="number">24</span>); &#125;</span><br><span class="line"><span class="function">BYTE <span class="title">L2</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> x ^ roll(x, <span class="number">13</span>) ^ roll(x, <span class="number">23</span>);&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">Tau</span><span class="params">(BYTE x)</span> </span>&#123;  <span class="comment">// SBOX 4 合一</span></span><br><span class="line">    <span class="keyword">return</span> (sbox[(x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">24</span>) </span><br><span class="line">        ^ (sbox[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">16</span>) </span><br><span class="line">        ^ (sbox[(x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">8</span>) </span><br><span class="line">        ^ (sbox[x &amp; <span class="number">0xff</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">T1</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> L1(Tau(x));&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">T2</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> L2(Tau(x));&#125;</span><br></pre></td></tr></table></figure><h2 id="加解密运算"><a href="#加解密运算" class="headerlink" title="加解密运算"></a>加解密运算</h2><h3 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h3><p>总共进行 32 轮，初始的输入为 $(X_0, X_1, X_2, X_3)$</p><p>输入为 $(X_i, X_{i+1}, X_{i+2}, X_{i+3})$</p><p>输出为 $(X_{i+1}, X_{i+2}, X_{i+3}, X_{i+4})$</p><p>其中，单个 $X_i$ 表示32位数据，$X_{i+4}$ 的计算方式如下：</p><script type="math/tex; mode=display">X_{i+4}=X_{i}\oplus T(X_{i+1}\oplus X_{i+2}\oplus X_{i+3}\oplus rk_i)</script><p>$T$ 由线性变换和非线性变换复合而成，即 $T(\cdot)=L(\tau(\cdot))$</p><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p>第 31 轮轮函数运算完成后，对 32 轮的输出值进行反序变换，最终输出密文。</p><script type="math/tex; mode=display">(Y_0,Y_1,Y_2,Y_3)=R(X_{32}, X_{33}, X_{34}, X_{35})=(X_{35}, X_{34}, X_{33}, X_{32})</script><p>解密与加密类似，唯一的不同是将轮密钥的使用顺序改为倒序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WORD <span class="title">exec</span><span class="params">(WORD _X, <span class="built_in">vector</span>&lt;BYTE&gt; rk, <span class="keyword">bool</span> enc)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;BYTE&gt; <span class="title">X</span><span class="params">(<span class="number">36</span>)</span></span>; </span><br><span class="line">    X[<span class="number">0</span>] = get&lt;<span class="number">0</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">1</span>] = get&lt;<span class="number">1</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">2</span>] = get&lt;<span class="number">2</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">3</span>] = get&lt;<span class="number">3</span>&gt;(_X);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; ++i) <span class="comment">// 32 轮运算</span></span><br><span class="line">        X[i + <span class="number">4</span>] = X[i] ^ T1(X[i + <span class="number">1</span>] ^ X[i + <span class="number">2</span>] ^ X[i + <span class="number">3</span>] ^ rk[enc ? i : <span class="number">31</span> - i]);</span><br><span class="line">    <span class="keyword">return</span> WORD(X[<span class="number">35</span>], X[<span class="number">34</span>], X[<span class="number">33</span>], X[<span class="number">32</span>]); <span class="comment">// 反序输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">WORD <span class="title">encrypt</span><span class="params">(WORD X, <span class="built_in">vector</span>&lt;BYTE&gt; rk)</span> </span>&#123; <span class="keyword">return</span> exec(X, rk, <span class="literal">true</span>);&#125;</span><br><span class="line"><span class="function">WORD <span class="title">decrypt</span><span class="params">(WORD X, <span class="built_in">vector</span>&lt;BYTE&gt; rk)</span> </span>&#123; <span class="keyword">return</span> exec(X, rk, <span class="literal">false</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="密钥拓展"><a href="#密钥拓展" class="headerlink" title="密钥拓展"></a>密钥拓展</h2><p>密钥拓展的输入分 3 部分，后两者为常数：</p><ul><li>加密密钥 $MK=(MK_0, MK_1, MK_2, MK_3)$。</li><li>系统参数 $FK=(FK_0, FK_1, FK_2, FK_3)$。</li><li>固定参数 $CK=(CK_0, CK_1,\cdots, CK_{30}, CK_{31})$</li></ul><p>计算方法如下：</p><p>首先，计算 $K_i=MK_i\oplus FK_i$，得到 $(K_0, K_1, K_2, K_3)$</p><p>之后，循环计算 32 轮得到 $rk_i$</p><script type="math/tex; mode=display">rk_i=K_{i+4}=K_i\oplus T'(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_i)</script><p>其中，$T’$ 与 $T$ 类似，但是需要使用另一个线性变换 $L’(\cdot)$，即 $T’(\cdot)=L’(\tau(\cdot))$</p><script type="math/tex; mode=display">L'(B)=B\oplus (B<<<13)\oplus (B<<<23)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;BYTE&gt; <span class="title">generateKey</span><span class="params">(WORD MK)</span> </span>&#123;</span><br><span class="line">    vector&lt;BYTE&gt; rk(32), K(36);</span><br><span class="line">    <span class="keyword">auto</span> [MK0, MK1, MK2, MK3] = MK;</span><br><span class="line">    <span class="keyword">auto</span> [FK0, FK1, FK2, FK3] = FK;</span><br><span class="line">    K[<span class="number">0</span>] = MK0 ^ FK0;</span><br><span class="line">    K[<span class="number">1</span>] = MK1 ^ FK1; </span><br><span class="line">    K[<span class="number">2</span>] = MK2 ^ FK2;</span><br><span class="line">    K[<span class="number">3</span>] = MK3 ^ FK3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; ++i) </span><br><span class="line">        rk[i] = K[i + <span class="number">4</span>] = K[i] ^ T2(K[i + <span class="number">1</span>] ^ K[i + <span class="number">2</span>] ^ K[i + <span class="number">3</span>] ^ CK[i]);</span><br><span class="line">    <span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SM4 </tag>
            
            <tag> CPP </tag>
            
            <tag> 分组密码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
