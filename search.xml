<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SM4 密码算法学习</title>
      <link href="/2022/12/04/SM4-CPP/"/>
      <url>/2022/12/04/SM4-CPP/</url>
      
        <content type="html"><![CDATA[<h1 id="SM4-算法概述"><a href="#SM4-算法概述" class="headerlink" title="SM4 算法概述"></a>SM4 算法概述</h1><p>SM4是一种分组密码算法，由我国国家密码管理局在2012年发布，常用于无线互联网加密等领域。</p><h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码是将一个明文作为整体加密并且通常得到的是与明文等长的密文分组。典型的分组大小是64位或者128位。同流密码一样，两个用户要共享一个对称加密密钥。</p><p>分组密码的输入为具有 $b$ 位长度固定的明文分组和密钥，输出为 $b$ 位的密文。明文长度若大于 $b$ 位，则可简单将其分为 $b$ 位一组的块。</p><h2 id="工作模式概述"><a href="#工作模式概述" class="headerlink" title="工作模式概述"></a>工作模式概述</h2><p>但是，每次使用相同的密钥队多个分组加密，则会引发许多安全问题（如对于相同的明文永远生成唯一的密文）。为了将分组密码应用于各种各样的实际应用，NIST 定义了五种“工作模式”。</p><ul><li>ECB：用相同的密钥队明文分组分别加密。</li><li>CBC：明文输入时上一个密文组和下一个明文组的异或。</li><li>CFB：一次处理 $s$ 位，上一次的密文作为输入，输出与明文异或。</li><li>OFB：与 CFB 类似，用加密函数的输出填充移位寄存器。</li><li>CTR：加密一个计数器，输出与明文异或。</li></ul><h1 id="SM4-算法流程"><a href="#SM4-算法流程" class="headerlink" title="SM4 算法流程"></a>SM4 算法流程</h1><p>SM4 算法采用 32 轮非对称 Feistel 结构，其明文和密文长度都是 128 位，加密过程和解密过程处了轮密钥的使用顺序相反外，其他都是一致的。 SM4 算法的整体结构如下图所示：</p><p><img src="SM4.png" alt="SM4算法流程"></p><p>SM4 主要涉及 3 种操作：轮密钥异或，非线性变换和线性变换。</p><ul><li>轮密钥异或指当前分组和当前轮密钥进行按位异或运算。</li><li>非线性变换通过 S 盒完成，实现密码算法的混淆。</li><li>线性变换指的是对非线性变换的输出进行拓展操作。</li></ul><h2 id="非线性变换"><a href="#非线性变换" class="headerlink" title="非线性变换"></a>非线性变换</h2><p>由 4 个并行的 S 盒完成，每个 S 盒映射 8 位，整体上实现对 32 位输入的映射，记为 $\tau(\cdot)$：</p><p><img src="SBOX.jpg" alt="SBOX"></p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>输入是非线性变换的输出，完成的是对 32 位输入的线性变换，记为 $L(\cdot)$：</p><script type="math/tex; mode=display">L(B)=B\oplus (B<<<2)\oplus (B<<<10)\oplus (B<<<18)\oplus (B<<<24)</script><p>其中用到的移位运算是 <strong>循环右移</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BYTE <span class="title">roll</span><span class="params">(BYTE x, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (x &lt;&lt; n) | (x &gt;&gt; (<span class="number">32</span> - n));&#125; <span class="comment">// 循环右移</span></span><br><span class="line"><span class="function">BYTE <span class="title">L1</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> x ^ roll(x, <span class="number">2</span>) ^ roll(x, <span class="number">10</span>) ^ roll(x, <span class="number">18</span>) ^ roll(x, <span class="number">24</span>); &#125;</span><br><span class="line"><span class="function">BYTE <span class="title">L2</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> x ^ roll(x, <span class="number">13</span>) ^ roll(x, <span class="number">23</span>);&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">Tau</span><span class="params">(BYTE x)</span> </span>&#123;  <span class="comment">// SBOX 4 合一</span></span><br><span class="line">    <span class="keyword">return</span> (sbox[(x &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">24</span>) </span><br><span class="line">        ^ (sbox[(x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">16</span>) </span><br><span class="line">        ^ (sbox[(x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">8</span>) </span><br><span class="line">        ^ (sbox[x &amp; <span class="number">0xff</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">T1</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> L1(Tau(x));&#125;</span><br><span class="line"><span class="function">BYTE <span class="title">T2</span><span class="params">(BYTE x)</span> </span>&#123; <span class="keyword">return</span> L2(Tau(x));&#125;</span><br></pre></td></tr></table></figure><h2 id="加解密运算"><a href="#加解密运算" class="headerlink" title="加解密运算"></a>加解密运算</h2><h3 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h3><p>总共进行 32 轮，初始的输入为 $(X_0, X_1, X_2, X_3)$</p><p>输入为 $(X_i, X_{i+1}, X_{i+2}, X_{i+3})$</p><p>输出为 $(X_{i+1}, X_{i+2}, X_{i+3}, X_{i+4})$</p><p>其中，单个 $X_i$ 表示32位数据，$X_{i+4}$ 的计算方式如下：</p><script type="math/tex; mode=display">X_{i+4}=X_{i}\oplus T(X_{i+1}\oplus X_{i+2}\oplus X_{i+3}\oplus rk_i)</script><p>$T$ 由线性变换和非线性变换复合而成，即 $T(\cdot)=L(\tau(\cdot))$</p><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><p>第 31 轮轮函数运算完成后，对 32 轮的输出值进行反序变换，最终输出密文。</p><script type="math/tex; mode=display">(Y_0,Y_1,Y_2,Y_3)=R(X_{32}, X_{33}, X_{34}, X_{35})=(X_{35}, X_{34}, X_{33}, X_{32})</script><p>解密与加密类似，唯一的不同是将轮密钥的使用顺序改为倒序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WORD <span class="title">exec</span><span class="params">(WORD _X, <span class="built_in">vector</span>&lt;BYTE&gt; rk, <span class="keyword">bool</span> enc)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;BYTE&gt; <span class="title">X</span><span class="params">(<span class="number">36</span>)</span></span>; </span><br><span class="line">    X[<span class="number">0</span>] = get&lt;<span class="number">0</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">1</span>] = get&lt;<span class="number">1</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">2</span>] = get&lt;<span class="number">2</span>&gt;(_X); </span><br><span class="line">    X[<span class="number">3</span>] = get&lt;<span class="number">3</span>&gt;(_X);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; ++i) <span class="comment">// 32 轮运算</span></span><br><span class="line">        X[i + <span class="number">4</span>] = X[i] ^ T1(X[i + <span class="number">1</span>] ^ X[i + <span class="number">2</span>] ^ X[i + <span class="number">3</span>] ^ rk[enc ? i : <span class="number">31</span> - i]);</span><br><span class="line">    <span class="keyword">return</span> WORD(X[<span class="number">35</span>], X[<span class="number">34</span>], X[<span class="number">33</span>], X[<span class="number">32</span>]); <span class="comment">// 反序输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">WORD <span class="title">encrypt</span><span class="params">(WORD X, <span class="built_in">vector</span>&lt;BYTE&gt; rk)</span> </span>&#123; <span class="keyword">return</span> exec(X, rk, <span class="literal">true</span>);&#125;</span><br><span class="line"><span class="function">WORD <span class="title">decrypt</span><span class="params">(WORD X, <span class="built_in">vector</span>&lt;BYTE&gt; rk)</span> </span>&#123; <span class="keyword">return</span> exec(X, rk, <span class="literal">false</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="密钥拓展"><a href="#密钥拓展" class="headerlink" title="密钥拓展"></a>密钥拓展</h2><p>密钥拓展的输入分 3 部分，后两者为常数：</p><ul><li>加密密钥 $MK=(MK_0, MK_1, MK_2, MK_3)$。</li><li>系统参数 $FK=(FK_0, FK_1, FK_2, FK_3)$。</li><li>固定参数 $CK=(CK_0, CK_1,\cdots, CK_{30}, CK_{31})$</li></ul><p>计算方法如下：</p><p>首先，计算 $K_i=MK_i\oplus FK_i$，得到 $(K_0, K_1, K_2, K_3)$</p><p>之后，循环计算 32 轮得到 $rk_i$</p><script type="math/tex; mode=display">rk_i=K_{i+4}=K_i\oplus T'(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_i)</script><p>其中，$T’$ 与 $T$ 类似，但是需要使用另一个线性变换 $L’(\cdot)$，即 $T’(\cdot)=L’(\tau(\cdot))$</p><script type="math/tex; mode=display">L'(B)=B\oplus (B<<<13)\oplus (B<<<23)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;BYTE&gt; <span class="title">generateKey</span><span class="params">(WORD MK)</span> </span>&#123;</span><br><span class="line">    vector&lt;BYTE&gt; rk(32), K(36);</span><br><span class="line">    <span class="keyword">auto</span> [MK0, MK1, MK2, MK3] = MK;</span><br><span class="line">    <span class="keyword">auto</span> [FK0, FK1, FK2, FK3] = FK;</span><br><span class="line">    K[<span class="number">0</span>] = MK0 ^ FK0;</span><br><span class="line">    K[<span class="number">1</span>] = MK1 ^ FK1; </span><br><span class="line">    K[<span class="number">2</span>] = MK2 ^ FK2;</span><br><span class="line">    K[<span class="number">3</span>] = MK3 ^ FK3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>; ++i) </span><br><span class="line">        rk[i] = K[i + <span class="number">4</span>] = K[i] ^ T2(K[i + <span class="number">1</span>] ^ K[i + <span class="number">2</span>] ^ K[i + <span class="number">3</span>] ^ CK[i]);</span><br><span class="line">    <span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SM4 </tag>
            
            <tag> CPP </tag>
            
            <tag> 分组密码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
